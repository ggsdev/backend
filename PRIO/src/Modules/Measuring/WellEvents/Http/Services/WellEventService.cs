using PRIO.src.Modules.Hierarchy.Installations.Interfaces;
using PRIO.src.Modules.Hierarchy.Wells.Infra.EF.Models;
using PRIO.src.Modules.Hierarchy.Wells.Interfaces;
using PRIO.src.Modules.Measuring.WellEvents.EF.Models;
using PRIO.src.Modules.Measuring.WellEvents.Interfaces;
using PRIO.src.Modules.Measuring.WellEvents.ViewModels;
using PRIO.src.Shared.Errors;

namespace PRIO.src.Modules.Measuring.WellEvents.Http.Services
{
    public class WellEventService
    {
        private readonly IWellEventRepository _wellEventRepository;
        private readonly IInstallationRepository _installationRepository;
        private readonly IWellRepository _wellRepository;
        private readonly IFieldRepository _fieldRepository;
        public WellEventService(IWellEventRepository wellEventRepository, IInstallationRepository installationRepository, IFieldRepository fieldRepository, IWellRepository wellRepository)
        {
            _wellEventRepository = wellEventRepository;
            _installationRepository = installationRepository;
            _fieldRepository = fieldRepository;
            _wellRepository = wellRepository;
        }
        public async Task CloseWellFieldEvent(CreateClosingEventViewModel body)
        {
            if (DateTime.TryParse(body.StartDate, out var parsedStartDate) is false)
                throw new BadRequestException("Formato de data inválido deve ser 'dd/MM/yyyy'.");

            var eventRelated = await _wellEventRepository
                .GetRelatedEvent(body.EventRelatedId);

            if (eventRelated is null)
                throw new NotFoundException("Evento relacionado não encontrado.");

            if (eventRelated.EventStatus.ToUpper() == "F")
                throw new ConflictException("Evento relacionado não pode ser de tipo 'Fechamento'.");

            var wellsList = new List<Well>();

            foreach (var well in body.Wells)
            {
                var wellInDatabase = await _wellRepository
                    .GetByIdAsync(well.WellId);

                if (wellInDatabase is null)
                    throw new NotFoundException(ErrorMessages.NotFound<Well>());

                var lastEvent = wellInDatabase.WellEvents
                    .LastOrDefault();

                if (lastEvent is null)
                    throw new ConflictException("O poço não possui um evento de abertura anterior.");

                if (lastEvent.EventStatus != "A")
                    throw new ConflictException("O último evento do poço deve ser de abertura para que seja possível cadastrar um evento de fechamento.");

                wellsList.Add(wellInDatabase);
            }

            var eventReason = new EventReason
            {
                Id = Guid.NewGuid(),
                Reason = body.Reason,
                StartDate = parsedStartDate
            };

            var eventReasons = new List<EventReason>
                {
                    eventReason
                };

            foreach (var well in wellsList)
            {
                var lastEvent = well.WellEvents
                   .LastOrDefault();

                var lastEventOfTypeClosing = well.WellEvents
                    .LastOrDefault(x => x.EventStatus == "F");

                var codeSequencial = string.Empty;

                if (lastEventOfTypeClosing is not null && int.TryParse(lastEventOfTypeClosing.IdAutoGenerated, out int lastCode))
                {
                    lastCode++;
                    codeSequencial = lastCode.ToString("0000");
                }
                else
                    codeSequencial = "0001";

                var closingEvent = new WellEvent
                {
                    Id = Guid.NewGuid(),
                    EventRelated = lastEvent,
                    EventStatus = "F",
                    StartDate = parsedStartDate,
                    SystemRelated = body.SystemRelated,
                    IdAutoGenerated = $"{well?.Field?.Name?[..3]}{codeSequencial}",
                    EventReasons = eventReasons,
                    StateANP = body.StateAnp,
                    StatusANP = body.StatusAnp,
                    Well = well,
                };

                await _wellEventRepository.Add(closingEvent);

                if (lastEvent is not null)
                {
                    lastEvent.EndDate = parsedStartDate;
                    lastEvent.Interval = (parsedStartDate - lastEvent.StartDate).TotalHours;

                    _wellEventRepository.Update(lastEvent);
                }
            }

            await _wellEventRepository.Save();
        }
        //public async Task<List<InstallationDTO>> GetUepsForWellEvent()
        //{
        //    var installations = await _installationRepository
        //        .GetUEPsAsync();

        //    foreach (var installation in installations)
        //    {
        //        foreach (var field in installation.Fields)
        //        {
        //            foreach (var well in field.Wells)
        //            {
        //                foreach (var wellEvent in well.WellEvents)
        //                {
        //                    var wellDto = 


        //                }

        //            }
        //        }
        //    }

        //    return installationsDTO;
        //}
    }
}
