using PRIO.src.Modules.Hierarchy.Fields.Infra.EF.Models;
using PRIO.src.Modules.Hierarchy.Installations.Interfaces;
using PRIO.src.Modules.Measuring.WellEvents.EF.Models;
using PRIO.src.Modules.Measuring.WellEvents.Interfaces;
using PRIO.src.Modules.Measuring.WellEvents.ViewModels;
using PRIO.src.Shared.Errors;

namespace PRIO.src.Modules.Measuring.WellEvents.Http.Services
{
    public class WellEventService
    {
        private readonly IWellEventRepository _wellEventRepository;
        private readonly IInstallationRepository _installationRepository;
        private readonly IFieldRepository _fieldRepository;
        public WellEventService(IWellEventRepository wellEventRepository, IInstallationRepository installationRepository, IFieldRepository fieldRepository)
        {
            _wellEventRepository = wellEventRepository;
            _installationRepository = installationRepository;
            _fieldRepository = fieldRepository;
        }
        public async Task CloseWellFieldEvent(CreateClosingEventViewModel body)
        {
            var eventRelated = await _wellEventRepository
                .GetRelatedEvent(body.EventRelatedId);

            if (eventRelated is null)
                throw new NotFoundException("Evento relacionado não encontrado.");

            if (eventRelated.EventStatus.ToUpper() == "F")
                throw new ConflictException("Evento relacionado não pode ser de tipo 'Fechamento'.");

            var uep = await _installationRepository
                .GetUepById(body.UepId);

            if (uep is null)
                throw new NotFoundException("UEP não encontrada.");

            var field = await _fieldRepository
                .GetByIdAsync(body.FieldId);

            if (field is null)
                throw new NotFoundException(ErrorMessages.NotFound<Field>());

            if (field.Wells is null || field.Wells.Count == 0)
                throw new NotFoundException("Não foram encontrados poços nesse campo.");

            foreach (var well in field.Wells)
            {
                var lastEvent = well.WellEvents
                    .LastOrDefault();

                if (lastEvent is null)
                    throw new ConflictException("O poço não possui um evento de abertura anterior.");

                if (lastEvent.EventStatus != "A")
                    throw new ConflictException("O último evento do poço deve ser de abertura para que seja possível cadastrar um evento de fechamento.");
            }

            var parsedStartDate = DateTime.Parse(body.StartDate);

            var eventReason = new EventReason
            {
                Id = Guid.NewGuid(),
                Reason = body.Reason,

                StartDate = parsedStartDate
            };

            var eventReasons = new List<EventReason>
                {
                    eventReason
                };

            foreach (var well in field.Wells)
            {
                var lastEvent = well.WellEvents
                   .LastOrDefault();

                var lastEventOfTypeClosing = well.WellEvents
                    .LastOrDefault(x => x.EventStatus == "F");

                var codeSequencial = string.Empty;

                if (lastEventOfTypeClosing is not null && int.TryParse(lastEventOfTypeClosing.IdAutoGenerated, out int lastCode))
                {
                    lastCode++;
                    codeSequencial = lastCode.ToString("0000");
                }
                else
                    codeSequencial = "0001";

                var closingEvent = new WellEvent
                {
                    Id = Guid.NewGuid(),
                    EventRelated = lastEvent,
                    EventStatus = "F",
                    StartDate = parsedStartDate,
                    SystemRelated = body.SystemRelated,
                    IdAutoGenerated = $"{well?.Field?.Name?[..3]}{codeSequencial}",
                    EventReasons = eventReasons,
                    StateANP = body.StateAnp,
                    StatusANP = body.StatusAnp,
                    Well = well,
                };

                await _wellEventRepository.Add(closingEvent);

                if (lastEvent is not null)
                {
                    lastEvent.EndDate = parsedStartDate;
                    lastEvent.Interval = (parsedStartDate - lastEvent.StartDate).TotalHours;

                    _wellEventRepository.Update(lastEvent);
                }

            }

            await _wellEventRepository.Save();
        }
    }
}
